/* tslint:disable */
/* eslint-disable */
/**
 * VocalVibe-Backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthSSOSchema
 */
export interface AuthSSOSchema {
    /**
     * 
     * @type {string}
     * @memberof AuthSSOSchema
     */
    'id_token': string;
    /**
     * 
     * @type {SSOType}
     * @memberof AuthSSOSchema
     */
    'sso_type': SSOType;
}


/**
 * 
 * @export
 * @interface CreateGroupRequestSchema
 */
export interface CreateGroupRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequestSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequestSchema
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateGroupRequestSchema
     */
    'created_by'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateSelfPracticeSessionRequestSchema
 */
export interface CreateSelfPracticeSessionRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateSelfPracticeSessionRequestSchema
     */
    'session_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateSelfPracticeSessionRequestSchema
     */
    'topic_id': number;
    /**
     * 
     * @type {SessionMediaType}
     * @memberof CreateSelfPracticeSessionRequestSchema
     */
    'media_type'?: SessionMediaType;
}


/**
 * 
 * @export
 * @interface CreateSessionRequestSchema
 */
export interface CreateSessionRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequestSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequestSchema
     */
    'description'?: string;
    /**
     * 
     * @type {SessionType}
     * @memberof CreateSessionRequestSchema
     */
    'session_type'?: SessionType;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionRequestSchema
     */
    'created_by'?: number | null;
}


/**
 * 
 * @export
 * @interface CreateTopicRequestSchema
 */
export interface CreateTopicRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateTopicRequestSchema
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTopicRequestSchema
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTopicRequestSchema
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTopicRequestSchema
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {TopicGenerationType}
     * @memberof CreateTopicRequestSchema
     */
    'generation_type'?: TopicGenerationType;
}


/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'is_deleted': boolean;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ListUserGroupsResponseSchema
 */
export interface ListUserGroupsResponseSchema {
    /**
     * 
     * @type {Array<Group>}
     * @memberof ListUserGroupsResponseSchema
     */
    'groups': Array<Group>;
}
/**
 * 
 * @export
 * @interface ListUserResponseSchema
 */
export interface ListUserResponseSchema {
    /**
     * 
     * @type {Array<User>}
     * @memberof ListUserResponseSchema
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface ListUsersInGroupsResponseSchema
 */
export interface ListUsersInGroupsResponseSchema {
    /**
     * 
     * @type {Array<User>}
     * @memberof ListUsersInGroupsResponseSchema
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface LoginUserSchema
 */
export interface LoginUserSchema {
    /**
     * 
     * @type {string}
     * @memberof LoginUserSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserSchema
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequestSchema
 */
export interface RefreshTokenRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequestSchema
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface RegisterUserSchema
 */
export interface RegisterUserSchema {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserSchema
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserSchema
     */
    'first_name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SSOType = {
    Google: 'GOOGLE',
    Facebook: 'FACEBOOK'
} as const;

export type SSOType = typeof SSOType[keyof typeof SSOType];


/**
 * 
 * @export
 * @interface SelfPracticeSession
 */
export interface SelfPracticeSession {
    /**
     * 
     * @type {number}
     * @memberof SelfPracticeSession
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelfPracticeSession
     */
    'session_id': string;
    /**
     * 
     * @type {SessionMediaType}
     * @memberof SelfPracticeSession
     */
    'media_type': SessionMediaType;
    /**
     * 
     * @type {string}
     * @memberof SelfPracticeSession
     */
    'session_recording_url': string | null;
    /**
     * 
     * @type {number}
     * @memberof SelfPracticeSession
     */
    'topic_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof SelfPracticeSession
     */
    'is_deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof SelfPracticeSession
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SelfPracticeSession
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'description': string;
    /**
     * 
     * @type {SessionType}
     * @memberof Session
     */
    'session_type': SessionType;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'created_by': number;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'is_deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SessionMediaType = {
    Audio: 'AUDIO',
    Video: 'VIDEO'
} as const;

export type SessionMediaType = typeof SessionMediaType[keyof typeof SessionMediaType];


/**
 * 
 * @export
 * @enum {string}
 */

export const SessionType = {
    SelfPractice: 'SELF_PRACTICE',
    Group: 'GROUP'
} as const;

export type SessionType = typeof SessionType[keyof typeof SessionType];


/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof Topic
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Topic
     */
    'tags': Array<string>;
    /**
     * 
     * @type {TopicGenerationType}
     * @memberof Topic
     */
    'generation_type': TopicGenerationType;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TopicGenerationType = {
    Seeded: 'SEEDED',
    AiGenerated: 'AI_GENERATED'
} as const;

export type TopicGenerationType = typeof TopicGenerationType[keyof typeof TopicGenerationType];


/**
 * 
 * @export
 * @interface TopicsResponseSchema
 */
export interface TopicsResponseSchema {
    /**
     * 
     * @type {Array<Topic>}
     * @memberof TopicsResponseSchema
     */
    'topics'?: Array<Topic>;
    /**
     * 
     * @type {number}
     * @memberof TopicsResponseSchema
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'middle_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'sso_provider': string | null;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    'traits': object;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {LoginUserSchema} loginUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginUserSchema: LoginUserSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginUserSchema' is not null or undefined
            assertParamExists('login', 'loginUserSchema', loginUserSchema)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginUserSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Sso
         * @param {AuthSSOSchema} authSSOSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginSso: async (authSSOSchema: AuthSSOSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authSSOSchema' is not null or undefined
            assertParamExists('loginSso', 'authSSOSchema', authSSOSchema)
            const localVarPath = `/api/v1/auth/sso/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSOSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Access Token
         * @param {RefreshTokenRequestSchema} refreshTokenRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (refreshTokenRequestSchema: RefreshTokenRequestSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequestSchema' is not null or undefined
            assertParamExists('refreshAccessToken', 'refreshTokenRequestSchema', refreshTokenRequestSchema)
            const localVarPath = `/api/v1/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {RegisterUserSchema} registerUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerUserSchema: RegisterUserSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserSchema' is not null or undefined
            assertParamExists('register', 'registerUserSchema', registerUserSchema)
            const localVarPath = `/api/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register Sso
         * @param {AuthSSOSchema} authSSOSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSso: async (authSSOSchema: AuthSSOSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authSSOSchema' is not null or undefined
            assertParamExists('registerSso', 'authSSOSchema', authSSOSchema)
            const localVarPath = `/api/v1/auth/sso/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSOSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginUserSchema} loginUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginUserSchema: LoginUserSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginUserSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login Sso
         * @param {AuthSSOSchema} authSSOSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginSso(authSSOSchema: AuthSSOSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginSso(authSSOSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginSso']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Access Token
         * @param {RefreshTokenRequestSchema} refreshTokenRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(refreshTokenRequestSchema: RefreshTokenRequestSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(refreshTokenRequestSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register
         * @param {RegisterUserSchema} registerUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerUserSchema: RegisterUserSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerUserSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register Sso
         * @param {AuthSSOSchema} authSSOSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSso(authSSOSchema: AuthSSOSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSso(authSSOSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.registerSso']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginUserSchema} loginUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginUserSchema: LoginUserSchema, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.login(loginUserSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login Sso
         * @param {AuthSSOSchema} authSSOSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginSso(authSSOSchema: AuthSSOSchema, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.loginSso(authSSOSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Access Token
         * @param {RefreshTokenRequestSchema} refreshTokenRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(refreshTokenRequestSchema: RefreshTokenRequestSchema, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.refreshAccessToken(refreshTokenRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {RegisterUserSchema} registerUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerUserSchema: RegisterUserSchema, options?: any): AxiosPromise<any> {
            return localVarFp.register(registerUserSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register Sso
         * @param {AuthSSOSchema} authSSOSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSso(authSSOSchema: AuthSSOSchema, options?: any): AxiosPromise<any> {
            return localVarFp.registerSso(authSSOSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 
     * @summary Login
     * @param {LoginUserSchema} loginUserSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    login(loginUserSchema: LoginUserSchema, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;

    /**
     * 
     * @summary Login Sso
     * @param {AuthSSOSchema} authSSOSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    loginSso(authSSOSchema: AuthSSOSchema, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;

    /**
     * 
     * @summary Refresh Access Token
     * @param {RefreshTokenRequestSchema} refreshTokenRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    refreshAccessToken(refreshTokenRequestSchema: RefreshTokenRequestSchema, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;

    /**
     * 
     * @summary Register
     * @param {RegisterUserSchema} registerUserSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    register(registerUserSchema: RegisterUserSchema, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Register Sso
     * @param {AuthSSOSchema} authSSOSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    registerSso(authSSOSchema: AuthSSOSchema, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 
     * @summary Login
     * @param {LoginUserSchema} loginUserSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginUserSchema: LoginUserSchema, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginUserSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login Sso
     * @param {AuthSSOSchema} authSSOSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginSso(authSSOSchema: AuthSSOSchema, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginSso(authSSOSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Access Token
     * @param {RefreshTokenRequestSchema} refreshTokenRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAccessToken(refreshTokenRequestSchema: RefreshTokenRequestSchema, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshAccessToken(refreshTokenRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {RegisterUserSchema} registerUserSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerUserSchema: RegisterUserSchema, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerUserSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register Sso
     * @param {AuthSSOSchema} authSSOSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerSso(authSSOSchema: AuthSSOSchema, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerSso(authSSOSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add User To Group
         * @param {string} groupId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToGroup: async (groupId: string, userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addUserToGroup', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserToGroup', 'userId', userId)
            const localVarPath = `/api/v1/group/{group_id}/user/{user_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Group
         * @param {CreateGroupRequestSchema} createGroupRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupRequestSchema: CreateGroupRequestSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupRequestSchema' is not null or undefined
            assertParamExists('createGroup', 'createGroupRequestSchema', createGroupRequestSchema)
            const localVarPath = `/api/v1/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/api/v1/group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users In Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersInGroup: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getUsersInGroup', 'groupId', groupId)
            const localVarPath = `/api/v1/group/{group_id}/users`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove User From Group
         * @param {string} groupId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromGroup: async (groupId: string, userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeUserFromGroup', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromGroup', 'userId', userId)
            const localVarPath = `/api/v1/group/{group_id}/user/{user_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add User To Group
         * @param {string} groupId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToGroup(groupId: string, userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToGroup(groupId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.addUserToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Group
         * @param {CreateGroupRequestSchema} createGroupRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupRequestSchema: CreateGroupRequestSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupRequestSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Users In Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersInGroup(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersInGroupsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersInGroup(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getUsersInGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove User From Group
         * @param {string} groupId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromGroup(groupId: string, userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromGroup(groupId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.removeUserFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Add User To Group
         * @param {string} groupId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToGroup(groupId: string, userId: number, options?: any): AxiosPromise<any> {
            return localVarFp.addUserToGroup(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Group
         * @param {CreateGroupRequestSchema} createGroupRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupRequestSchema: CreateGroupRequestSchema, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(createGroupRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users In Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersInGroup(groupId: string, options?: any): AxiosPromise<ListUsersInGroupsResponseSchema> {
            return localVarFp.getUsersInGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove User From Group
         * @param {string} groupId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromGroup(groupId: string, userId: number, options?: any): AxiosPromise<object> {
            return localVarFp.removeUserFromGroup(groupId, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - interface
 * @export
 * @interface GroupApi
 */
export interface GroupApiInterface {
    /**
     * 
     * @summary Add User To Group
     * @param {string} groupId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    addUserToGroup(groupId: string, userId: number, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Create Group
     * @param {CreateGroupRequestSchema} createGroupRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    createGroup(createGroupRequestSchema: CreateGroupRequestSchema, options?: RawAxiosRequestConfig): AxiosPromise<Group>;

    /**
     * 
     * @summary Get Group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    getGroup(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Group>;

    /**
     * 
     * @summary Get Users In Group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    getUsersInGroup(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListUsersInGroupsResponseSchema>;

    /**
     * 
     * @summary Remove User From Group
     * @param {string} groupId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    removeUserFromGroup(groupId: string, userId: number, options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI implements GroupApiInterface {
    /**
     * 
     * @summary Add User To Group
     * @param {string} groupId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addUserToGroup(groupId: string, userId: number, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).addUserToGroup(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Group
     * @param {CreateGroupRequestSchema} createGroupRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(createGroupRequestSchema: CreateGroupRequestSchema, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).createGroup(createGroupRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users In Group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getUsersInGroup(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getUsersInGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove User From Group
     * @param {string} groupId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public removeUserFromGroup(groupId: string, userId: number, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).removeUserFromGroup(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Self Practice Session
         * @param {CreateSelfPracticeSessionRequestSchema} createSelfPracticeSessionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelfPracticeSession: async (createSelfPracticeSessionRequestSchema: CreateSelfPracticeSessionRequestSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSelfPracticeSessionRequestSchema' is not null or undefined
            assertParamExists('createSelfPracticeSession', 'createSelfPracticeSessionRequestSchema', createSelfPracticeSessionRequestSchema)
            const localVarPath = `/api/v1/session/practice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSelfPracticeSessionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Session
         * @param {CreateSessionRequestSchema} createSessionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (createSessionRequestSchema: CreateSessionRequestSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSessionRequestSchema' is not null or undefined
            assertParamExists('createSession', 'createSessionRequestSchema', createSessionRequestSchema)
            const localVarPath = `/api/v1/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Self Practice Session
         * @param {CreateSelfPracticeSessionRequestSchema} createSelfPracticeSessionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSelfPracticeSession(createSelfPracticeSessionRequestSchema: CreateSelfPracticeSessionRequestSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelfPracticeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSelfPracticeSession(createSelfPracticeSessionRequestSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createSelfPracticeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Session
         * @param {CreateSessionRequestSchema} createSessionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(createSessionRequestSchema: CreateSessionRequestSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(createSessionRequestSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Self Practice Session
         * @param {CreateSelfPracticeSessionRequestSchema} createSelfPracticeSessionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelfPracticeSession(createSelfPracticeSessionRequestSchema: CreateSelfPracticeSessionRequestSchema, options?: any): AxiosPromise<SelfPracticeSession> {
            return localVarFp.createSelfPracticeSession(createSelfPracticeSessionRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Session
         * @param {CreateSessionRequestSchema} createSessionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(createSessionRequestSchema: CreateSessionRequestSchema, options?: any): AxiosPromise<Session> {
            return localVarFp.createSession(createSessionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - interface
 * @export
 * @interface SessionApi
 */
export interface SessionApiInterface {
    /**
     * 
     * @summary Create Self Practice Session
     * @param {CreateSelfPracticeSessionRequestSchema} createSelfPracticeSessionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApiInterface
     */
    createSelfPracticeSession(createSelfPracticeSessionRequestSchema: CreateSelfPracticeSessionRequestSchema, options?: RawAxiosRequestConfig): AxiosPromise<SelfPracticeSession>;

    /**
     * 
     * @summary Create Session
     * @param {CreateSessionRequestSchema} createSessionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApiInterface
     */
    createSession(createSessionRequestSchema: CreateSessionRequestSchema, options?: RawAxiosRequestConfig): AxiosPromise<Session>;

}

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI implements SessionApiInterface {
    /**
     * 
     * @summary Create Self Practice Session
     * @param {CreateSelfPracticeSessionRequestSchema} createSelfPracticeSessionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public createSelfPracticeSession(createSelfPracticeSessionRequestSchema: CreateSelfPracticeSessionRequestSchema, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createSelfPracticeSession(createSelfPracticeSessionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Session
     * @param {CreateSessionRequestSchema} createSessionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public createSession(createSessionRequestSchema: CreateSessionRequestSchema, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createSession(createSessionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Topic
         * @param {CreateTopicRequestSchema} createTopicRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic: async (createTopicRequestSchema: CreateTopicRequestSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTopicRequestSchema' is not null or undefined
            assertParamExists('createTopic', 'createTopicRequestSchema', createTopicRequestSchema)
            const localVarPath = `/api/v1/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTopicRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Topics
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Topic
         * @param {CreateTopicRequestSchema} createTopicRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTopic(createTopicRequestSchema: CreateTopicRequestSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTopic(createTopicRequestSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.createTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Topics
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopics(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopics(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.getTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Topic
         * @param {CreateTopicRequestSchema} createTopicRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic(createTopicRequestSchema: CreateTopicRequestSchema, options?: any): AxiosPromise<Topic> {
            return localVarFp.createTopic(createTopicRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Topics
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics(page?: number, perPage?: number, options?: any): AxiosPromise<TopicsResponseSchema> {
            return localVarFp.getTopics(page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicApi - interface
 * @export
 * @interface TopicApi
 */
export interface TopicApiInterface {
    /**
     * 
     * @summary Create Topic
     * @param {CreateTopicRequestSchema} createTopicRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApiInterface
     */
    createTopic(createTopicRequestSchema: CreateTopicRequestSchema, options?: RawAxiosRequestConfig): AxiosPromise<Topic>;

    /**
     * 
     * @summary Get Topics
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApiInterface
     */
    getTopics(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TopicsResponseSchema>;

}

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI implements TopicApiInterface {
    /**
     * 
     * @summary Create Topic
     * @param {CreateTopicRequestSchema} createTopicRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public createTopic(createTopicRequestSchema: CreateTopicRequestSchema, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).createTopic(createTopicRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Topics
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getTopics(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).getTopics(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List User Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whoami
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List User Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUserGroupsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserGroups(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.listUserGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUserResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Whoami
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.whoami']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary List User Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserGroups(options?: any): AxiosPromise<ListUserGroupsResponseSchema> {
            return localVarFp.listUserGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): AxiosPromise<ListUserResponseSchema> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whoami
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<User> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary List User Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listUserGroups(options?: RawAxiosRequestConfig): AxiosPromise<ListUserGroupsResponseSchema>;

    /**
     * 
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listUsers(options?: RawAxiosRequestConfig): AxiosPromise<ListUserResponseSchema>;

    /**
     * 
     * @summary Whoami
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    whoami(options?: RawAxiosRequestConfig): AxiosPromise<User>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary List User Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserGroups(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUsers(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whoami
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public whoami(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}



